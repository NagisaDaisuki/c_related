#include <iostream>
#include <memory>
#include <vector>
#include <string>


/*
    控制实例化
        当模板被使用时才会进行实例化
        这一特性意味着相同的实例可能出现在多个对象文件中
        
    在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重
    在新标准中，可以通过显式实例化(explicit instantiaion)来避免
    这种开销

    一个显式实例化有如下形式：
        extern template class declaration; //实例化声明
        template declaration; //实例化定义

    当编译器遇到一个实例化定义（与声明相对）时，它为其生成代码

    如果在当前文件中有实例化声明，则不能在本文件进行实例化定义
    
    对于每个实例化声明，在程序中某个位置必须有其显式的实例化定义


    实例化定义会实例化所有成员
        一个类模板的实例化定义会实例化该模板的所有成员
        包括内联的成员函数

*/

/*
    效率与灵活性    

        shared_ptr<> 和 unique_ptr<> 在删除器上实现的diff
    
    
    -在运行时绑定删除器
    shared_ptr不是将删除器直接保存为一个成员，因为删除器的类型直到运行时
    才能知道 
    实际上，在一个shared_ptr 的生存期中，我们可以随时改变其删除器的类型
    我们可以使用一种类型的删除器构造一个shared_ptr ,随后使用reset
    赋予此shared_ptr 另一种类型的删除器
    通常，类成员的类型在运行时是不能改变的。因此不能直接保存删除器
    
    -在编译时绑定删除器
    在unique_ptr 中删除器的类型是类类型的一部分
    即unique_ptr 有两个模板参数
    
    一个表示它所管理的指针，另一个表示删除器的类型
    由于删除器的类型是unique_ptr 的一部分，因此删除器成员
    的类型在编译时是知道的，从而删除器可以直接保存在unique_Ptr对象中

    通过在编译器时绑定删除器，unique_ptr 避免了间接调用删除器的运行时开销
    通过在运行时绑定删除器，shared_ptr 使用户重载删除器更为方便
    
    

*/

int main()
{

    return 0;
}
