#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <algorithm>

#include <type_traits> // 新头文件 获取传入引用的元素类型
// 用于函数模板中传入迭代器类型 元素类型的推断


/*
    模板实参推断
      对于函数模板，编译器利用调用中的函数实参来确定其模板参数。
      从函数实参来确定模板实参的过程被称为模板实参推断(template argument deduction)


    类型转换与模板类型参数
      与非模板参数一样，我们在一次调用中传递给函数模板的实参被用来初始化函数的形参
      如果一个函数形参的类型使用了模板类型参数，那么它采用特殊的初始化规则

    编译器通常不是对实参进行类型转换，而是生成一个新的模板实例

    能在调用中应用于函数模板的包括 const转换 和 数组或函数到指针的转换
    
    其他类型转换如算术转换、派生类向基类转换、以及用户定义的转换
    都不能应用于函数模板
    

    尾置返回类型与类型转换
      当我们希望用户确定返回类型时，用显式模板实参表示模板函数的返回类型是很有效的
      但是在其他情况下，要求显式返回模板实参会给用户增添额外负担，而且不会带来什么
      好处
    
      如果我们写一个接受一对迭代器和返回序列中的一个元素的引用
    template<typename It>
    ??? &fcn(It beg,It end)
    {
      // 处理序列
      return *beg; // 返回序列中一个元素的引用
    }

    // 我们并不知道返回结果的准确类型，但是知道所需类型是所处理的序列的元素类型
    // 在编译器遇到函数的参数列表之前，beg都是不存在的。
    // 为了定义此函数，我们必须使用尾置返回类型
    
    template<typename It>1
    auto fcn(It beg,It end) -> decltype(*beg) //尾置返回类型，告诉编译器
                                                // fcn的返回类型与解引用
                                                // beg参数的结果类型相同
    {
      // 处理序列
      return *beg;
    }

    有时我们无法直接获得所需要的类型。例如，我们可能希望编写一个类似
    fcn的函数但是返回一个元素的值而非引用

    在编写这个函数的过程中，我们面临一个问题：对于传递的参数的类型，我们几乎一无所知
    在此函数中，我们知道唯一可以使用的操作是迭代器操作，而所有迭代器操作都不会生成
    元素，只能生成元素的引用
    
    为了获得元素类型，我们可以使用标准库的类型转换(type transformation)模板
    这些模板定义在头文件type_traits中。这个头文件中的类通常用于所谓的模板元程序设计
    
    可以使用remove_reference来获得元素类型
    remove_reference 模板有一个模板类型参数和 一个名为type的public类型成员
    
    remove_reference<int&> type表示被引用的类型 在这里type的类型为int
    remove_reference<string&> type的类型为string
    remove_reference<decltype(*beg)>::type 的类型为 迭代器指向的元素的类型



    函数指针和实参推断
      当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值，
      编译器使用指针的类型来推断模板实参
      

    模板实参推断和引用
    
    引用折叠和右值引用参数
    
    ---->template<typename T> void f3(T&&);
    ---->f3(42); // 实参是一个int类型的右值模板参数是int
    
    假定i是一个int对象，我们可能认为向f3(i)这样的调用
    是不合法的。而通常我们不能将一个右值引用绑定到一个左值上
    但是C++语言在正常绑定规则之外定义了两个例外规则，允许这种绑定

    这两个例外规则是move这种标准库设施正确工作的基础
    
    第一个例外规则影响右值引用参数的推断如何进行
    当我们调用f3(i)时，编译器推断T的类型为int& ,而非int 
    
    T被推断为int& 看起来好像意味着f3的函数参数应该是一个类型int& 的右值引用
    通常，我们不能(直接)定义一个引用的引用。但是，通过类型别名或者通过模板类型
    参数间接定义是可以的

    第二个例外绑定规则：如果我们间接创建一个引用的引用，则这些引用形成了折叠
    在所有情况下(除了一个例外),引用会被折叠成一个普通的左值引用类型
    在新标准中，折叠规则扩展到右值引用。只有一种特殊情况下引用会被折叠
    成右值引用：右值引用的右值引用会被折叠成右值引用

    -即对于一个给定类型X:
        X& &,X& && X&& &都折叠成类型X&
        X&& &&折叠成类型X&&

    引用折叠只能运用于间接创建的引用的引用，如类型别名或模板参数


*/

template<typename It> // 显式标明typename表示在类成员表示一个类型
auto fcn(It beg,It end)-> typename std::remove_reference<decltype(*beg)>::type 
{
    return *beg; //返回序列中一个元素的拷贝
}


// 编写接受右值引用参数的模板函数
template<typename T>
void f3(T&& val)
{
    T t = val; // 拷贝还是绑定一个引用?
    t = fcn(t); // 赋值只改变t还是既改变t又改变val? 
    if(val == t) {} // 若T是引用类型，则一直为true
}

// 函数参数传入左值和右值得不到相同的结果
// 在实际中，右值引用通常用于两种情况：模板转发其实参或模板被重载


int main()
{
    
    return 0;

}
